<!$Id: atmel-header.html 19278 2009-11-23 09:15:44Z sschneid $>
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>AVR2025: IEEE 802.15.4 MAC Reference Manual</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="2"><p><A href=http://www.atmel.com ><img src="../..//graphics//atmel.jpg"/ border=0></A></p><br /></td>
    <td colspan="2"> <strong><font face="Helvetica" color="#000000" size="+3">Microcontroller Wireless Solutions</font></strong></td>
    <td colspan="2"><p><A href=http://www.atmel.com/products/AVR><img src="../..//graphics//AVR_logo_blue.gif"/ border=0></A></p><br /></td>
  </tr>
  <tr>
    <td colspan="6" height="1" background="../..//graphics//blue.gif"></td>
  </tr>
</table>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1>pal.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
General PAL functions for AVR ATxmega MCUs. 
<p>
This file implements generic PAL function for AVR ATxmega MCUs.<p>
<dl class="rcs" compact><dt><b>Id</b></dt><dd><a class="el" href="a00001.html" title="General PAL functions for AVR ATxmega MCUs.">pal.c</a> 21606 2010-04-14 14:09:54Z uwalter </dd></dl>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <p>
Support email: <a href="mailto:avr@atmel.com">avr@atmel.com</a> </dd></dl>

<p>Definition in file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>

<p>
<a href="a00010.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#d673763b5d09e381e1636c72ce1cc6e0">eeprom_flush_buffer</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#f2cb9c8f46a7af62933ea7346666eb43">eeprom_read_byte</a> (uint8_t *addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#53c5f85c2d49fa85444f778872c556a7">eeprom_wait_for_NVM</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#87c81347a49b12a05c77d19a2dc3b7a0">eeprom_write_byte</a> (uint8_t addr, uint8_t value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#d3a6d3a49225a4f2d46c33207de01473">NVM_EXEC</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#80779665aa57408f41636b7b0a55e2dc">pal_alert</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">retval_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#7ba90b2aacd564c33138bf6902bd8bca">pal_init</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">retval_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#cdfefdb2d0670ac148ba156199f62178">pal_ps_get</a> (<a class="el" href="a00002.html#04c3479332019daef5ff782f68d7a0e3">ps_type_t</a> ps_type, uint16_t start_addr, uint16_t length, void *value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">retval_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#4e10cc025eb8507fe5f176e21336da37">pal_ps_set</a> (uint16_t start_addr, uint16_t length, void *value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html#057e433e0200eb99b5f67c5336dbc323">pal_task</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78d2fd18666afec116f176d46debb4e7"></a><!-- doxytag: member="pal.c::sys_time" ref="78d2fd18666afec116f176d46debb4e7" args="" -->
volatile uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>sys_time</b></td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="d673763b5d09e381e1636c72ce1cc6e0"></a><!-- doxytag: member="pal.c::eeprom_flush_buffer" ref="d673763b5d09e381e1636c72ce1cc6e0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eeprom_flush_buffer           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush temporary EEPROM page buffer. 
<p>
This function flushes the EEPROM page buffers. This function will cancel any ongoing EEPROM page buffer loading operations, if any. This function also works for memory mapped EEPROM access. Implementation used from application note AVR1315.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The EEPROM write operations will automatically flush the buffer for you. </dd></dl>

<p>Definition at line <a class="el" href="a00010.html#l00192">192</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00010.html#l00142">eeprom_wait_for_NVM()</a>, and <a class="el" href="a00010.html#l00117">NVM_EXEC()</a>.</p>

<p>Referenced by <a class="el" href="a00010.html#l00213">eeprom_write_byte()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f2cb9c8f46a7af62933ea7346666eb43"></a><!-- doxytag: member="pal.c::eeprom_read_byte" ref="f2cb9c8f46a7af62933ea7346666eb43" args="(uint8_t *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t eeprom_read_byte           </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read one byte from EEPROM address. 
<p>
Implementation used from application note AVR1315.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to EEPROM address </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Value at EEPROM address </dd></dl>

<p>Definition at line <a class="el" href="a00010.html#l00159">159</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00010.html#l00142">eeprom_wait_for_NVM()</a>, and <a class="el" href="a00010.html#l00117">NVM_EXEC()</a>.</p>

<p>Referenced by <a class="el" href="a00010.html#l00251">pal_ps_get()</a>, and <a class="el" href="a00010.html#l00296">pal_ps_set()</a>.</p>

</div>
</div><p>
<a class="anchor" name="53c5f85c2d49fa85444f778872c556a7"></a><!-- doxytag: member="pal.c::eeprom_wait_for_NVM" ref="53c5f85c2d49fa85444f778872c556a7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eeprom_wait_for_NVM           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for any NVM access to finish, including EEPROM. 
<p>
This function is blcoking and waits for any NVM access to finish, including EEPROM. Use this function before any EEPROM accesses, if you are not certain that any previous operations are finished yet, like an EEPROM write. Implementation used from application note AVR1315. 
<p>Definition at line <a class="el" href="a00010.html#l00142">142</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>Referenced by <a class="el" href="a00010.html#l00192">eeprom_flush_buffer()</a>, and <a class="el" href="a00010.html#l00159">eeprom_read_byte()</a>.</p>

</div>
</div><p>
<a class="anchor" name="87c81347a49b12a05c77d19a2dc3b7a0"></a><!-- doxytag: member="pal.c::eeprom_write_byte" ref="87c81347a49b12a05c77d19a2dc3b7a0" args="(uint8_t addr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eeprom_write_byte           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write one byte to EEPROM address. 
<p>
Implementation used from application note AVR1315.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>EEPROM address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>for EEPROM address </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="a00010.html#l00213">213</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00010.html#l00192">eeprom_flush_buffer()</a>, and <a class="el" href="a00010.html#l00117">NVM_EXEC()</a>.</p>

<p>Referenced by <a class="el" href="a00010.html#l00296">pal_ps_set()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d3a6d3a49225a4f2d46c33207de01473"></a><!-- doxytag: member="pal.c::NVM_EXEC" ref="d3a6d3a49225a4f2d46c33207de01473" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void NVM_EXEC           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-Volatile Memory Execute Command. 
<p>
This macro set the CCP register before setting the CMDEX bit in the NVM.CTRLA register. Implementation used from application note AVR1315.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The CMDEX bit must be set within 4 clock cycles after setting the protection byte in the CCP register. </dd></dl>

<p>Definition at line <a class="el" href="a00010.html#l00117">117</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>Referenced by <a class="el" href="a00010.html#l00192">eeprom_flush_buffer()</a>, <a class="el" href="a00010.html#l00159">eeprom_read_byte()</a>, and <a class="el" href="a00010.html#l00213">eeprom_write_byte()</a>.</p>

</div>
</div><p>
<a class="anchor" name="80779665aa57408f41636b7b0a55e2dc"></a><!-- doxytag: member="pal.c::pal_alert" ref="80779665aa57408f41636b7b0a55e2dc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pal_alert           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alert indication. 
<p>
This Function can be used by any application to indicate an error condition. The function is blocking and does never return. 
<p>Definition at line <a class="el" href="a00010.html#l00329">329</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00017.html#l00502">pal_timer_delay()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7ba90b2aacd564c33138bf6902bd8bca"></a><!-- doxytag: member="pal.c::pal_init" ref="7ba90b2aacd564c33138bf6902bd8bca" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">retval_t pal_init           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialization of PAL. 
<p>
This function initializes the PAL.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>MAC_SUCCESS if PAL initialization is successful, FAILURE otherwise </dd></dl>

<p>Definition at line <a class="el" href="a00010.html#l00059">59</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00014.html#l00110">clock_init()</a>, <a class="el" href="a00014.html#l00085">event_system_init()</a>, <a class="el" href="a00014.html#l00150">gpio_init()</a>, <a class="el" href="a00014.html#l00099">interrupt_system_init()</a>, <a class="el" href="a00019.html#l00039">MAC_SUCCESS</a>, and <a class="el" href="a00018.html#l00066">trx_interface_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cdfefdb2d0670ac148ba156199f62178"></a><!-- doxytag: member="pal.c::pal_ps_get" ref="cdfefdb2d0670ac148ba156199f62178" args="(ps_type_t ps_type, uint16_t start_addr, uint16_t length, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">retval_t pal_ps_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html#04c3479332019daef5ff782f68d7a0e3">ps_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>ps_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get data from persistence storage. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ps_type</em>&nbsp;</td><td>Persistence storage type </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start_addr</em>&nbsp;</td><td>Start offset within EEPROM </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes to read from EEPROM </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Data from persistence storage</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>MAC_SUCCESS if everything went OK else FAILURE </dd></dl>

<p>Definition at line <a class="el" href="a00010.html#l00251">251</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00010.html#l00159">eeprom_read_byte()</a>, <a class="el" href="a00012.html#l00126">EXTERN_EEPROM</a>, <a class="el" href="a00019.html#l00043">FAILURE</a>, <a class="el" href="a00012.html#l00124">INTERN_EEPROM</a>, <a class="el" href="a00019.html#l00064">MAC_INVALID_PARAMETER</a>, and <a class="el" href="a00019.html#l00039">MAC_SUCCESS</a>.</p>

</div>
</div><p>
<a class="anchor" name="4e10cc025eb8507fe5f176e21336da37"></a><!-- doxytag: member="pal.c::pal_ps_set" ref="4e10cc025eb8507fe5f176e21336da37" args="(uint16_t start_addr, uint16_t length, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">retval_t pal_ps_set           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data to persistence storage. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start_addr</em>&nbsp;</td><td>Start address offset within EEPROM </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes to be written to EEPROM </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Data to persistence storage</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>MAC_SUCCESS if everything went OK else FAILURE </dd></dl>

<p>Definition at line <a class="el" href="a00010.html#l00296">296</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00010.html#l00159">eeprom_read_byte()</a>, <a class="el" href="a00010.html#l00213">eeprom_write_byte()</a>, <a class="el" href="a00019.html#l00043">FAILURE</a>, and <a class="el" href="a00019.html#l00039">MAC_SUCCESS</a>.</p>

</div>
</div><p>
<a class="anchor" name="057e433e0200eb99b5f67c5336dbc323"></a><!-- doxytag: member="pal.c::pal_task" ref="057e433e0200eb99b5f67c5336dbc323" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pal_task           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Services timer and sio handler. 
<p>
This function calls sio &amp; timer handling functions. 
<p>Definition at line <a class="el" href="a00010.html#l00081">81</a> of file <a class="el" href="a00010.html">pal.c</a>.</p>

<p>References <a class="el" href="a00017.html#l00112">timer_service()</a>.</p>

</div>
</div><p>
</div>
<!$Id: atmel-footer.html 19276 2009-11-23 09:04:48Z sschneid $>
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <title>@DOC_TITLE@</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>

<table width="100%" height="10%" bgcolor="#FFFFFF">
  <tr>
    <td colspan="6" height="1" background="..//img//blue.gif"></td>
  </tr>

  <tr>
    <td colspan="6">
    <address style="align: right;"><small>
Generated on Mon Aug 23 09:08:37 2010 for Platform Reference Manual - Radio Extender board REB231 V4.0.1 with ATxmega128A1 and AT86RF231 on STK600 and REB to STK600 Adapter by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.6</small></address>
    </td>
  </tr>

</table>
